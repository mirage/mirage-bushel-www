<div class="ocaml_top"><div class="ocaml_summary"><div class="info">Non-blocking streaming Unicode codec.<p><code class="code">Uutf</code> is a non-blocking streaming codec to  <a href="#decode">decode</a> and
 <a href="#encode">encode</a> the  <a href="http://www.ietf.org/rfc/rfc3629.txt">UTF-8</a>,  <a href="http://www.ietf.org/rfc/rfc2781.txt">UTF-16</a>, UTF-16LE
and UTF-16BE encoding schemes. It can efficiently work character by
character without blocking on IO. Decoders perform
character position tracking and support newline normalization.</p><p>Functions are also provided to fold over the
characters of UTF encoded OCaml string values and to
directly encode characters in OCaml Buffer.t
values.</p><p>See  <a href="#examples">examples</a> of use.</p><p><em>Release 0.9.3 - Daniel BÃ¼nzli &lt;daniel.buenzl i@erratique.ch&gt;</em></p><h3 id="3_TITLE">References</h3>
<ul><li>The Unicode Consortium.
<em> <a href="http://www.unicode.org/versions/latest">The Unicode Standard</a></em>.
(latest version)</li></ul></div></div>
<div class="ocaml_content"><div class="info"><h1 id="basic">Unicode characters</h1><p><code class="code">Uutf</code> uses the term character for a Unicode
 <a href="http://unicode.org/glossary/#unicode_scalar_value">scalar
value</a> which is an integer value in the ranges <code class="code">0x0000</code>
... <code class="code">0xD7FF</code> and <code class="code">0xE000</code> ... <code class="code">0x10FFFF</code>. This should not be
confused with a Unicode
 <a href="http://unicode.org/glossary/#code_point">code point</a>, which is
a scalar value or a (textually meaningless)
 <a href="http://unicode.org/glossary/#surrogate_code_point">surrogate
code point</a>.</p></div>
<pre class="odoccode"><span class="TYPEuchar"><span class="keyword">type</span> uchar</span> = <code class="type">int</code></pre><div class="info">The type for Unicode characters. Any value of this type returned
by <code class="code">Uutf</code> is a Unicode
 <a href="http://unicode.org/glossary/#unicode_scalar_value">scalar value</a>.</div>
<pre class="odoccode"><span class="VALu_bom"><span class="keyword">val</span> u_bom</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a></code></pre><div class="info"><code class="code">u_bom</code> is the  <a href="http://unicode.org/glossary/#byte_order_mark">byte
order mark</a> (BOM) character (<code class="code">U+FEFF</code>).</div>
<pre class="odoccode"><span class="VALu_rep"><span class="keyword">val</span> u_rep</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a></code></pre><div class="info"><code class="code">u_rep</code> is the
 <a href="http://unicode.org/glossary/#replacement_character">replacement</a>
character (<code class="code">U+FFFD</code>).</div>
<pre class="odoccode"><span class="VALis_uchar"><span class="keyword">val</span> is_uchar</span> : <code class="type">int -&gt; bool</code></pre><div class="info"><code class="code">is_uchar cp</code> is <code class="code">true</code> iff <code class="code">cp</code> is a Unicode
 <a href="http://unicode.org/glossary/#unicode_scalar_value">scalar value</a>.</div>
<pre class="odoccode"><span class="VALcp_to_string"><span class="keyword">val</span> cp_to_string</span> : <code class="type">int -&gt; string</code></pre><div class="info"><code class="code">cp_to_string cp</code> represents the
 <a href="http://unicode.org/glossary/#code_point">code point</a> <code class="code">cp</code> in
ASCII according to the Unicode notational convention
(see Appendix A in Unicode 6.1.0).
If <code class="code">cp</code> is not a valid code point <code class="code">&quot;U+Invalid(X)&quot;</code> is
returned where <code class="code">X</code> is the hexadecimal integer value.<p><b>Warning.</b> Not thread safe. Use pp_cp for thread safety.</p></div>
<pre class="odoccode"><span class="VALpp_cp"><span class="keyword">val</span> pp_cp</span> : <code class="type">Format.formatter -&gt; int -&gt; unit</code></pre><div class="info"><code class="code">pp_cp ppf cp</code> prints <code class="code">cp</code> on <code class="code">ppf</code>. See cp_to_string.</div>
<div class="info"><h1 id="schemes">Unicode encoding schemes</h1></div>
<pre class="odoccode"><span class="TYPEencoding"><span class="keyword">type</span> encoding</span> = <code class="type">[ `UTF_16 | `UTF_16BE | `UTF_16LE | `UTF_8 ]</code></pre><div class="info">The type for Unicode
 <a href="http://unicode.org/glossary/#character_encoding_scheme">encoding
schemes</a>.</div>
<pre class="odoccode"><span class="TYPEdecoder_encoding"><span class="keyword">type</span> decoder_encoding</span> = <code class="type">[ `ISO_8859_1 | `US_ASCII | `UTF_16 | `UTF_16BE | `UTF_16LE | `UTF_8 ]</code></pre><div class="info">The type for encoding schemes <em>decoded</em> by <code class="code">Uutf</code>. Unicode encoding
schemes plus  <a href="http://tools.ietf.org/html/rfc20">US-ASCII</a> and
 <a href="http://www.ecma-international.org/publications/standards/Ecma-094.htm">ISO/IEC 8859-1</a> (latin-1).</div>
<pre class="odoccode"><span class="VALencoding_of_string"><span class="keyword">val</span> encoding_of_string</span> : <code class="type">string -&gt; <a href="http://mirage.github.io/uutf/#Uutf.decoder_encoding" class="ocaml_internal">decoder_encoding</a> option</code></pre><div class="info"><code class="code">encoding_of_string s</code> converts a (case insensitive)
 <a href="http://www.iana.org/assignments/character-sets">IANA character set name</a>
to an encoding.</div>
<pre class="odoccode"><span class="VALencoding_to_string"><span class="keyword">val</span> encoding_to_string</span> : <code class="type">[&lt; <a href="http://mirage.github.io/uutf/#Uutf.decoder_encoding" class="ocaml_internal">decoder_encoding</a> ] -&gt; string</code></pre><div class="info"><code class="code">encoding_to_string e</code> is a
 <a href="http://www.iana.org/assignments/character-sets">IANA character set name</a>
for <code class="code">e</code>.</div>
<div class="info"><h1 id="decode">Decode</h1></div>
<pre class="odoccode"><span class="TYPEsrc"><span class="keyword">type</span> src</span> = <code class="type">[ `Channel of in_channel | `Manual | `String of string ]</code></pre><div class="info">The type for input sources. With a <code class="code">`Manual</code> source the client
must provide input with Manual.src.</div>
<pre class="odoccode"><span class="TYPEnln"><span class="keyword">type</span> nln</span> = <code class="type">[ `ASCII of <a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a> | `NLF of <a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a> | `Readline of <a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a> ]</code></pre><div class="info">The type for newline normalizations. The variant argument is the
normalization character.
<ul><li><code class="code">`ASCII</code>, normalizes CR (<code class="code">U+000D</code>), LF (<code class="code">U+000A</code>) and CRLF
(&lt;<code class="code">U+000D</code>, <code class="code">U+000A</code>&gt;).</li><li><code class="code">`NLF</code>, normalizes the Unicode newline function (NLF). This is
NEL (<code class="code">U+0085</code>) and the normalizations of <code class="code">`ASCII</code>.</li><li><code class="code">`Readline</code>, normalizes for a Unicode readline function. This is FF
(<code class="code">U+000C</code>), LS (<code class="code">U+2028</code>), PS (<code class="code">U+2029</code>), and the normalizations
of <code class="code">`NLF</code>.</li></ul>
Used with an appropriate normalization character the <code class="code">`NLF</code> and
<code class="code">`Readline</code> normalizations allow to implement all the different
recommendations of Unicode's newline guidelines (section 5.8 in
Unicode 6.1.0).</div>
<pre class="odoccode"><span class="TYPEdecoder"><span class="keyword">type</span> decoder</span></pre><div class="info">The type for decoders.</div>
<pre class="odoccode"><span class="VALdecoder"><span class="keyword">val</span> decoder</span> : <code class="type">?nln:[&lt; <a href="http://mirage.github.io/uutf/#Uutf.nln" class="ocaml_internal">nln</a> ] -&gt; ?encoding:[&lt; <a href="http://mirage.github.io/uutf/#Uutf.decoder_encoding" class="ocaml_internal">decoder_encoding</a> ] -&gt; [&lt; <a href="http://mirage.github.io/uutf/#Uutf.src" class="ocaml_internal">src</a> ] -&gt; <a href="http://mirage.github.io/uutf/#Uutf.decoder" class="ocaml_internal">decoder</a></code></pre><div class="info"><code class="code">decoder nln encoding src</code> is a decoder that inputs from <code class="code">src</code>.<p><b>Byte order mark.</b>
 <a href="http://unicode.org/glossary/#byte_order_mark">Byte order mark</a>
(BOM) constraints are application dependent and prone to
misunderstandings (see the
 <a href="http://www.unicode.org/faq/utf_bom.html#BOM">FAQ</a>). Hence,
<code class="code">Uutf</code> decoders have a simple rule: an <em>initial BOM is always
removed from the input and not counted in character position
tracking</em>. The function decoder_removed_bom does however return
<code class="code">true</code> if a BOM was removed so that all the information can be
recovered if needed.</p><p>For UTF-16BE and UTF-16LE the above rule is a violation of
conformance D96 and D97 of the standard. <code class="code">Uutf</code> favors the idea
that if there's a BOM, decoding with <code class="code">`UTF_16</code> or the <code class="code">`UTF_16XX</code>
corresponding to the BOM should decode the same character sequence
(this is not the case if you stick to the standard). The client
can however regain conformance by consulting the result of
decoder_removed_bom and take appropriate action.</p><p><b>Encoding.</b> <code class="code">encoding</code> specifies the decoded encoding
scheme. If <code class="code">`UTF_16</code> is used the endianness is determined
according to the standard: from a
 <a href="http://unicode.org/glossary/#byte_order_mark">BOM</a>
if there is one, <code class="code">`UTF_16BE</code> otherwise.</p><p>If <code class="code">encoding</code> is unspecified it is guessed. The result of a guess
can only be <code class="code">`UTF_8</code>, <code class="code">`UTF_16BE</code> or <code class="code">`UTF_16LE</code>. The heuristic
looks at the first three bytes of input (or less if impossible)
and takes the <em>first</em> matching byte pattern in the table below.
</p><pre class="code"><code>xx = any byte
.. = any byte or no byte (input too small)
pp = positive byte 
uu = valid UTF-8 first byte

Bytes    | Guess     | Rationale
---------+-----------+-----------------------------------------------
EF BB BF | `UTF_8    | UTF-8 BOM
FE FF .. | `UTF_16BE | UTF-16BE BOM
FF FE .. | `UTF_16LE | UTF-16LE BOM
00 pp .. | `UTF_16BE | ASCII UTF-16BE and U+0000 is often forbidden
pp 00 .. | `UTF_16LE | ASCII UTF-16LE and U+0000 is often forbidden
uu .. .. | `UTF_8    | ASCII UTF-8 or valid UTF-8 first byte.
xx xx .. | `UTF_16BE | Not UTF-8 =&gt; UTF-16, no BOM =&gt; UTF-16BE
.. .. .. | `UTF_8    | Single malformed UTF-8 byte or no input. </code></pre>
This heuristic is compatible both with BOM based
recognitition and
 <a href="http://tools.ietf.org/html/rfc4627#section-3">JSON-like encoding
recognition</a> that relies on ASCII being present at the beginning
of the stream. Also, decoder_removed_bom will tell the client
if the guess was BOM based.<p><b>Newline normalization.</b> If <code class="code">nln</code> is specified, the given
newline normalization is performed, see nln. Otherwise
all newlines are returned as found in the input.</p><p><b>Character position.</b> The line number, column number and
character count of the last decoded character (including
<code class="code">`Malformed</code> ones) are respectively returned by decoder_line,
decoder_col and decoder_count. Before the first call to
decode the line number is <code class="code">1</code> and the column is <code class="code">0</code>. Each
decode returning <code class="code">`Uchar</code> or <code class="code">`Malformed</code> increments the column
until a newline. On a newline, the line number is incremented and
the column set to zero. For example the line is <code class="code">2</code> and column <code class="code">0</code>
after the first newline was decoded. This can be understood as if decode
was moving an insertion point to the right in the data. A <em>newline</em> is anything normalized by <code class="code">`Readline</code>, see nln.</p><p><code class="code">Uutf</code> assumes that each Unicode scalar value has a column width
of 1. The same assumption may not be made by the display program
(e.g. for <code class="code">emacs</code>' compilation mode you need to set
<code class="code">compilation-error-screen-columns</code> to <code class="code">nil</code>). For implementing
more involved column width increments yourself, look into
 <a href="http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c"><code class="code">wcwidth</code></a> and
 <a href="http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">grapheme cluster boundaries</a>.</p></div>
<pre class="odoccode"><span class="VALdecode"><span class="keyword">val</span> decode</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.decoder" class="ocaml_internal">decoder</a> -&gt; [ `Await | `End | `Malformed of string | `Uchar of <a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a> ]</code></pre><div class="info"><code class="code">decode d</code> is:
<ul><li><code class="code">`Await</code> if <code class="code">d</code> has a <code class="code">`Manual</code> input source and awaits
for more input. The client must use Manual.src to provide it.</li><li><code class="code">`Uchar u</code> if a Unicode scalar value <code class="code">u</code> was decoded.</li><li><code class="code">`End</code> if the end of input was reached.</li><li><code class="code">`Malformed bytes</code> if the <code class="code">bytes</code> sequence is malformed according to
the decoded encoding scheme. If you are interested in a best-effort
decoding you can still continue to decode after an error until the
decoder synchronizes again on valid bytes. It may however be a good
idea to signal the malformed characters by adding an u_rep
character to the parsed data, see the  <a href="#examples">examples</a>.</li></ul><p><b>Note.</b> Repeated invocation always eventually returns <code class="code">`End</code>, even
in case of errors.</p></div>
<pre class="odoccode"><span class="VALdecoder_encoding"><span class="keyword">val</span> decoder_encoding</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.decoder" class="ocaml_internal">decoder</a> -&gt; <a href="http://mirage.github.io/uutf/#Uutf.decoder_encoding" class="ocaml_internal">decoder_encoding</a></code></pre><div class="info"><code class="code">decoder_encoding d</code> is <code class="code">d</code>'s the decoded encoding scheme of <code class="code">d</code>.<p><b>Warning.</b> If the decoder guesses the encoding or uses <code class="code">`UTF_16</code>,
rely on this value only after the first <code class="code">`Uchar</code> was decoded.</p></div>
<pre class="odoccode"><span class="VALset_decoder_encoding"><span class="keyword">val</span> set_decoder_encoding</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.decoder" class="ocaml_internal">decoder</a> -&gt; [&lt; <a href="http://mirage.github.io/uutf/#Uutf.decoder_encoding" class="ocaml_internal">decoder_encoding</a> ] -&gt; unit</code></pre><div class="info"><code class="code">set_decoder_encoding d enc</code> changes the decoded encoding
to <code class="code">enc</code> after decoding started.<p><b>Warning.</b> Call only after decode was called on <code class="code">d</code> and that the
last call to it returned something different from <code class="code">`Await</code> or data may
be lost. After encoding guess wait for at least three <code class="code">`Uchar</code>s.</p></div>
<pre class="odoccode"><span class="VALdecoder_line"><span class="keyword">val</span> decoder_line</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.decoder" class="ocaml_internal">decoder</a> -&gt; int</code></pre><div class="info"><code class="code">decoder_line d</code> is the line number of the last
decoded (or malformed) character. See decoder for details.</div>
<pre class="odoccode"><span class="VALdecoder_col"><span class="keyword">val</span> decoder_col</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.decoder" class="ocaml_internal">decoder</a> -&gt; int</code></pre><div class="info"><code class="code">decoder_col d</code> is the column number of the last decoded
(or malformed) character. See decoder for details.</div>
<pre class="odoccode"><span class="VALdecoder_count"><span class="keyword">val</span> decoder_count</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.decoder" class="ocaml_internal">decoder</a> -&gt; int</code></pre><div class="info"><code class="code">decoder_count d</code> is the number of characters already decoded on <code class="code">d</code>
(including malformed ones). See decoder for details.</div>
<pre class="odoccode"><span class="VALdecoder_removed_bom"><span class="keyword">val</span> decoder_removed_bom</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.decoder" class="ocaml_internal">decoder</a> -&gt; bool</code></pre><div class="info"><code class="code">decoder_removed_bom d</code> is <code class="code">true</code> iff an <em>initial</em>
 <a href="http://unicode.org/glossary/#byte_order_mark">BOM</a> was
removed from the input stream. See decoder for details.</div>
<pre class="odoccode"><span class="VALdecoder_src"><span class="keyword">val</span> decoder_src</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.decoder" class="ocaml_internal">decoder</a> -&gt; <a href="http://mirage.github.io/uutf/#Uutf.src" class="ocaml_internal">src</a></code></pre><div class="info"><code class="code">decoder_src d</code> is <code class="code">d</code>'s input source.</div>
<pre class="odoccode"><span class="VALdecoder_nln"><span class="keyword">val</span> decoder_nln</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.decoder" class="ocaml_internal">decoder</a> -&gt; <a href="http://mirage.github.io/uutf/#Uutf.nln" class="ocaml_internal">nln</a> option</code></pre><div class="info"><code class="code">decoder_nln d</code> returns <code class="code">d</code>'s newline normalization (if any).</div>
<pre class="odoccode"><span class="VALpp_decode"><span class="keyword">val</span> pp_decode</span> : <code class="type">Format.formatter -&gt;
[&lt; `Await | `End | `Malformed of string | `Uchar of <a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a> ] -&gt; unit</code></pre><div class="info"><code class="code">pp_decode ppf v</code> prints an unspecified representation of <code class="code">v</code> on
<code class="code">ppf</code>.</div>
<div class="info"><h1 id="encode">Encode</h1></div>
<pre class="odoccode"><span class="TYPEdst"><span class="keyword">type</span> dst</span> = <code class="type">[ `Buffer of Buffer.t | `Channel of out_channel | `Manual ]</code></pre><div class="info">The type for output destinations. With a <code class="code">`Manual</code> destination the client
must provide output storage with Manual.dst.</div>
<pre class="odoccode"><span class="TYPEencoder"><span class="keyword">type</span> encoder</span></pre><div class="info">The type for Unicode encoders.</div>
<pre class="odoccode"><span class="VALencoder"><span class="keyword">val</span> encoder</span> : <code class="type">[&lt; <a href="http://mirage.github.io/uutf/#Uutf.encoding" class="ocaml_internal">encoding</a> ] -&gt; [&lt; <a href="http://mirage.github.io/uutf/#Uutf.dst" class="ocaml_internal">dst</a> ] -&gt; <a href="http://mirage.github.io/uutf/#Uutf.encoder" class="ocaml_internal">encoder</a></code></pre><div class="info"><code class="code">encoder encoding dst</code> is an encoder for <code class="code">encoding</code> that outputs
to <code class="code">dst</code>.<p><b>Note.</b> No initial
 <a href="http://unicode.org/glossary/#byte_order_mark">BOM</a>
is encoded. If needed, this duty is left to the client.</p></div>
<pre class="odoccode"><span class="VALencode"><span class="keyword">val</span> encode</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.encoder" class="ocaml_internal">encoder</a> -&gt; [&lt; `Await | `End | `Uchar of <a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a> ] -&gt; [ `Ok | `Partial ]</code></pre><div class="info"><code class="code">encode e v</code> is :
<ul><li><code class="code">`Partial</code> iff <code class="code">e</code> has a <code class="code">`Manual</code> destination and needs more output
storage. The client must use Manual.dst to provide a new buffer
and then call encode with <code class="code">`Await</code> until <code class="code">`Ok</code> is returned.</li><li><code class="code">`Ok</code> when the encoder is ready to encode a new <code class="code">`Uchar</code> or <code class="code">`End</code></li></ul><p>For <code class="code">`Manual</code> destination, encoding <code class="code">`End</code> always returns
<code class="code">`Partial</code>, the client should continue as usual with <code class="code">`Await</code>
until <code class="code">`Ok</code> is returned at which point Manual.dst_rem <code class="code">e</code> is
guaranteed to be the size of the last provided buffer (i.e. nothing
was written).</p><p><b>Warning.</b> The function assumes that <code class="code">u</code> is a Unicode
 <a href="http://unicode.org/glossary/#unicode_scalar_value">scalar value</a>.
If you are handling foreign data you can use is_uchar to assert that.</p><p><b>Raises.</b> <code class="code">Invalid_argument</code> if an <code class="code">`Uchar</code> or <code class="code">`End</code> is encoded
after a <code class="code">`Partial</code> encode.</p></div>
<pre class="odoccode"><span class="VALencoder_encoding"><span class="keyword">val</span> encoder_encoding</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.encoder" class="ocaml_internal">encoder</a> -&gt; <a href="http://mirage.github.io/uutf/#Uutf.encoding" class="ocaml_internal">encoding</a></code></pre><div class="info"><code class="code">encoder_encoding e</code> is <code class="code">e</code>'s encoding.</div>
<pre class="odoccode"><span class="VALencoder_dst"><span class="keyword">val</span> encoder_dst</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.encoder" class="ocaml_internal">encoder</a> -&gt; <a href="http://mirage.github.io/uutf/#Uutf.dst" class="ocaml_internal">dst</a></code></pre><div class="info"><code class="code">encoder_dst e</code> is <code class="code">e</code>'s output destination.</div>
<div class="info"><h1 id="manual">Manual sources and destinations.</h1></div>
<div class="ocaml_module" name="Manual"><pre class="odoccode"><span class="keyword">module</span> <a href="http://mirage.github.io/uutf/#Uutf.Manual" class="ocaml_internal">Manual</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"><div class="info">Manual sources and destinations.<p><b>Warning.</b> Use only with <code class="code">`Manual</code> decoder and encoders.</p></div></div><div class="ocaml_content">
<pre class="odoccode"><span class="VALsrc"><span class="keyword">val</span> src</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.decoder" class="ocaml_internal">decoder</a> -&gt; string -&gt; int -&gt; int -&gt; unit</code></pre><div class="info"><code class="code">src d s j l</code> provides <code class="code">d</code> with <code class="code">l</code> bytes to read, starting at
<code class="code">j</code> in <code class="code">s</code>. This byte range is read by calls to decode with <code class="code">d</code>
until <code class="code">`Await</code> is returned. To signal the end of input call the function
with <code class="code">l = 0</code>.</div>
<pre class="odoccode"><span class="VALdst"><span class="keyword">val</span> dst</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.encoder" class="ocaml_internal">encoder</a> -&gt; string -&gt; int -&gt; int -&gt; unit</code></pre><div class="info"><code class="code">dst e s j l</code> provides <code class="code">e</code> with <code class="code">l</code> bytes to write, starting
at <code class="code">j</code> in <code class="code">s</code>. This byte range is written by calls to encode with <code class="code">e</code>
until <code class="code">`Partial</code> is returned. Use dst_rem to know the remaining
number of non-written free bytes in <code class="code">s</code>.</div>
<pre class="odoccode"><span class="VALdst_rem"><span class="keyword">val</span> dst_rem</span> : <code class="type"><a href="http://mirage.github.io/uutf/#Uutf.encoder" class="ocaml_internal">encoder</a> -&gt; int</code></pre><div class="info"><code class="code">dst_rem e</code> is the remaining number of non-written, free bytes
in the last buffer provided with Manual.dst.</div></div></div>
<div class="info"><h1 id="strbuf">String folders and Buffer encoders</h1></div>
<div class="ocaml_module" name="String"><pre class="odoccode"><span class="keyword">module</span> <a href="http://mirage.github.io/uutf/#Uutf.String" class="ocaml_internal">String</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"><div class="info">Fold over the characters of UTF encoded OCaml <code class="code">string</code> values.</div></div><div class="ocaml_content">
<div class="info"><h1 id="1_TITLE">Encoding guess</h1></div>
<pre class="odoccode"><span class="VALencoding_guess"><span class="keyword">val</span> encoding_guess</span> : <code class="type">string -&gt; [ `UTF_16BE | `UTF_16LE | `UTF_8 ] * bool</code></pre><div class="info"><code class="code">encoding_guess s</code> is the encoding guessed for <code class="code">s</code> coupled with
<code class="code">true</code> iff there's an initial
 <a href="http://unicode.org/glossary/#byte_order_mark">BOM</a>.</div>
<div class="info"><h1 id="1_TITLE">String folders</h1><p><b>Note.</b> Initial  <a href="http://unicode.org/glossary/#byte_order_mark">BOM</a>s
are also folded over.</p></div>
<pre class="odoccode"><span class="TYPEfolder"><span class="keyword">type</span> <code class="type">'a </code>folder</span> = <code class="type">'a -&gt; int -&gt; [ `Malformed of string | `Uchar of <a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a> ] -&gt; 'a</code></pre><div class="info">The type for character folders. The integer is the index in the
string where the <code class="code">`Uchar</code> or <code class="code">`Malformed</code> starts.</div>
<pre class="odoccode"><span class="VALfold_utf_8"><span class="keyword">val</span> fold_utf_8</span> : <code class="type">'a <a href="http://mirage.github.io/uutf/#Uutf.String.folder" class="ocaml_internal">folder</a> -&gt; 'a -&gt; string -&gt; 'a</code></pre><div class="info"><code class="code">fold_utf_8 f a s</code> is
<code class="code">f (</code> ... <code class="code">(f (f a 0 u</code><span class="SK_custom">{_0 }</span><code class="code">) j</code><span class="SK_custom">{_1 }</span><code class="code">u</code><span class="SK_custom">{_1 }</span><code class="code">)</code> ... <code class="code">)</code> ... <code class="code">) 
      j</code><span class="SK_custom">{_n }</span><code class="code">u</code><span class="SK_custom">{_n }</span>
where <code class="code">u</code><span class="SK_custom">{_i }</span>, <code class="code">j</code><span class="SK_custom">{_i }</span> are the Unicode
 <a href="http://unicode.org/glossary/#unicode_scalar_value">scalar value</a>
and the starting position of the characters in the
UTF-8 encoded string <code class="code">s</code>.</div>
<pre class="odoccode"><span class="VALfold_utf_16be"><span class="keyword">val</span> fold_utf_16be</span> : <code class="type">'a <a href="http://mirage.github.io/uutf/#Uutf.String.folder" class="ocaml_internal">folder</a> -&gt; 'a -&gt; string -&gt; 'a</code></pre><div class="info"><code class="code">fold_utf_16be f a s</code> is
<code class="code">f (</code> ... <code class="code">(f (f a 0 u</code><span class="SK_custom">{_0 }</span><code class="code">) j</code><span class="SK_custom">{_1 }</span><code class="code">u</code><span class="SK_custom">{_1 }</span><code class="code">)</code> ... <code class="code">)</code> ... <code class="code">)
      j</code><span class="SK_custom">{_n }</span><code class="code">u</code><span class="SK_custom">{_n }</span>
where <code class="code">u</code><span class="SK_custom">{_i }</span>, <code class="code">j</code><span class="SK_custom">{_i }</span> are the Unicode
 <a href="http://unicode.org/glossary/#unicode_scalar_value">scalar value</a>
and the starting position of the characters in the
UTF-16BE encoded string <code class="code">s</code>.</div>
<pre class="odoccode"><span class="VALfold_utf_16le"><span class="keyword">val</span> fold_utf_16le</span> : <code class="type">'a <a href="http://mirage.github.io/uutf/#Uutf.String.folder" class="ocaml_internal">folder</a> -&gt; 'a -&gt; string -&gt; 'a</code></pre><div class="info"><code class="code">fold_utf_16le f a s</code> is
<code class="code">f (</code> ... <code class="code">(f (f a 0 u</code><span class="SK_custom">{_0 }</span><code class="code">) j</code><span class="SK_custom">{_1 }</span><code class="code">u</code><span class="SK_custom">{_1 }</span><code class="code">)</code> ... <code class="code">)</code> ... <code class="code">)
      j</code><span class="SK_custom">{_n }</span><code class="code">u</code><span class="SK_custom">{_n }</span>
where <code class="code">u</code><span class="SK_custom">{_i }</span>, <code class="code">j</code><span class="SK_custom">{_i }</span> are the Unicode
 <a href="http://unicode.org/glossary/#unicode_scalar_value">scalar value</a>
and the starting position of the characters in the
UTF-16LE encoded string <code class="code">s</code>.</div></div></div>
<div class="ocaml_module" name="Buffer"><pre class="odoccode"><span class="keyword">module</span> <a href="http://mirage.github.io/uutf/#Uutf.Buffer" class="ocaml_internal">Buffer</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"><div class="info">UTF encode characters in OCaml Buffer.t values.</div></div><div class="ocaml_content">
<div class="info"><h1 id="1_TITLE">Buffer encoders</h1><p><b>Warning.</b> All the functions below assumes that <code class="code">u</code> is a
 <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode
scalar value</a>. If you are handling foreign data you
can use is_uchar to assert that.</p></div>
<pre class="odoccode"><span class="VALadd_utf_8"><span class="keyword">val</span> add_utf_8</span> : <code class="type">Buffer.t -&gt; <a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a> -&gt; unit</code></pre><div class="info"><code class="code">add_utf_8 b u</code> adds the UTF-8 encoding of the
 <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode
scalar value</a> <code class="code">u</code> to <code class="code">b</code>.</div>
<pre class="odoccode"><span class="VALadd_utf_16be"><span class="keyword">val</span> add_utf_16be</span> : <code class="type">Buffer.t -&gt; <a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a> -&gt; unit</code></pre><div class="info"><code class="code">add_utf_16be b u</code> adds the UTF-16BE encoding of the
 <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode
scalar value</a> <code class="code">u</code> to <code class="code">b</code>.</div>
<pre class="odoccode"><span class="VALadd_utf_16le"><span class="keyword">val</span> add_utf_16le</span> : <code class="type">Buffer.t -&gt; <a href="http://mirage.github.io/uutf/#Uutf.uchar" class="ocaml_internal">uchar</a> -&gt; unit</code></pre><div class="info"><code class="code">add_utf_16le b u</code> adds the UTF-16LE encoding of the
 <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode
scalar value</a> <code class="code">u</code> to <code class="code">b</code>.</div></div></div>
<div class="info"><h1 id="examples">Examples</h1><h2 id="readlines">Read lines</h2><p>The value of <code class="code">lines src</code> is the list of lines in <code class="code">src</code> as UTF-8
encoded OCaml strings. Line breaks are determined according to the
recommendation R4 for a <code class="code">readline</code> function in section 5.8 of
Unicode 6.1.0. If a decoding error occurs we silently replace the
malformed sequence by the replacement character u_rep and continue.
</p><pre class="code"><code>let lines ?encoding (src : [`Channel of in_channel | `String of string]) =
  let rec loop d buf acc = match Uutf.decode d with 
  | `Uchar 0x000A -&gt; 
      let line = Buffer.contents buf in
      Buffer.clear buf; loop d buf (line :: acc)
  | `Uchar u -&gt; Uutf.Buffer.add_utf_8 buf u; loop d buf acc
  | `End -&gt; List.rev (Buffer.contents buf :: acc)  
  | `Malformed _ -&gt; Uutf.Buffer.add_utf_8 buf Uutf.u_rep; loop d buf acc
  | `Await -&gt; assert false
  in
  let nln = `Readline 0x000A in
  loop (Uutf.decoder ~nln ?encoding src) (Buffer.create 512) []</code></pre><p>Using the <code class="code">`Manual</code> interface, <code class="code">lines_fd</code> does the same but on a Unix file
descriptor.
</p><pre class="code"><code>let lines_fd ?encoding (fd : Unix.file_descr) =
  let rec loop fd s d buf acc = match Uutf.decode d with 
  | `Uchar 0x000A -&gt; 
      let line = Buffer.contents buf in
      Buffer.clear buf; loop fd s d buf (line :: acc)
  | `Uchar u -&gt; Uutf.Buffer.add_utf_8 buf u; loop fd s d buf acc
  | `End -&gt; List.rev (Buffer.contents buf :: acc)
  | `Malformed _ -&gt; Uutf.Buffer.add_utf_8 buf Uutf.u_rep; loop fd s d buf acc
  | `Await -&gt;
      let rec unix_read fd s j l = try Unix.read fd s j l with 
      | Unix.Unix_error (Unix.EINTR, _, _) -&gt; unix_read fd s j l 
      in
      let rc = unix_read fd s 0 (String.length s) in 
      Uutf.Manual.src d s 0 rc; loop fd s d buf acc
  in
  let s = String.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let nln = `Readline 0x000A in
  loop fd s (Uutf.decoder ~nln ?encoding `Manual) (Buffer.create 512) []</code></pre><h2 id="recode">Recode</h2><p>The result of <code class="code">recode src out_encoding dst</code> has the characters of
<code class="code">src</code> written on <code class="code">dst</code> with encoding <code class="code">out_encoding</code>. If a
decoding error occurs we silently replace the malformed sequence
by the replacement character u_rep and continue. Note that we
don't add an initial
 <a href="http://unicode.org/glossary/#byte_order_mark">BOM</a> to <code class="code">dst</code>,
recoding will thus loose the initial BOM <code class="code">src</code> may have. Whether
this is a problem or not depends on the context.
</p><pre class="code"><code>let recode ?nln ?encoding out_encoding 
    (src : [`Channel of in_channel | `String of string])
    (dst : [`Channel of out_channel | `Buffer of Buffer.t])
  = 
  let rec loop d e = match Uutf.decode d with 
  | `Uchar _ as u -&gt; ignore (Uutf.encode e u); loop d e 
  | `End -&gt; ignore (Uutf.encode e `End)
  | `Malformed _ -&gt; ignore (Uutf.encode e (`Uchar Uutf.u_rep)); loop d e 
  | `Await -&gt; assert false
  in
  let d = Uutf.decoder ?nln ?encoding src in 
  let e = Uutf.encoder out_encoding dst in
  loop d e</code></pre>
Using the <code class="code">`Manual</code> interface, <code class="code">recode_fd</code> does the same but between
Unix file descriptors.
<pre class="code"><code>let recode_fd ?nln ?encoding out_encoding 
    (fdi : Unix.file_descr) 
    (fdo : Unix.file_descr) 
  = 
  let rec encode fd s e v = match Uutf.encode e v with `Ok -&gt; () 
  | `Partial -&gt; 
      let rec unix_write fd s j l = 
        let rec write fd s j l = try Unix.single_write fd s j l with 
        | Unix.Unix_error (Unix.EINTR, _, _) -&gt; write fd s j l 
        in
        let wc = write fd s j l in 
        if wc &lt; l then unix_write fd s (j + wc) (l - wc) else ()
      in
      unix_write fd s 0 (String.length s - Uutf.Manual.dst_rem e); 
      Uutf.Manual.dst e s 0 (String.length s);
      encode fd s e `Await
  in
  let rec loop fdi fdo ds es d e = match Uutf.decode d with 
  | `Uchar _ as u -&gt; encode fdo es e u; loop fdi fdo ds es d e 
  | `End -&gt; encode fdo es e `End
  | `Malformed _ -&gt; encode fdo es e (`Uchar Uutf.u_rep); loop fdi fdo ds es d e 
  | `Await -&gt;
      let rec unix_read fd s j l = try Unix.read fd s j l with 
      | Unix.Unix_error (Unix.EINTR, _, _) -&gt; unix_read fd s j l 
      in
      let rc = unix_read fdi ds 0 (String.length ds) in 
      Uutf.Manual.src d ds 0 rc; loop fdi fdo ds es d e 
  in
  let ds = String.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let es = String.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let d = Uutf.decoder ?nln ?encoding `Manual in 
  let e = Uutf.encoder out_encoding `Manual in
  Uutf.Manual.dst e es 0 (String.length es);
  loop fdi fdo ds es d e</code></pre></div>
</div></div>