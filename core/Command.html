<div class="ocaml_top"><div class="ocaml_summary"><div class="info">purely functional command line parsing</div></div>
<div class="ocaml_content"><div class="ocaml_module" name="Spec"><pre class="odoccode"><span class="keyword">module</span> <a href="http://mirage.github.io/core/#Command.Spec" class="ocaml_internal">Spec</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"><div class="info">composable command-line specifications</div></div><div class="ocaml_content">
<div class="info"><h1 id="1_TITLE">command parameters</h1></div>
<pre class="odoccode"><span class="TYPEparam"><span class="keyword">type</span> <code class="type">'a </code>param</span></pre><div class="info">specification of an individual parameter to the command's main function</div>
<pre class="odoccode"><span class="VALconst"><span class="keyword">val</span> const</span> : <code class="type">'a -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.param" class="ocaml_internal">param</a></code></pre><div class="info">a hard-coded parameter</div>
<pre class="odoccode"><span class="VALmap"><span class="keyword">val</span> map</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.param" class="ocaml_internal">param</a> -&gt; f:('a -&gt; 'b) -&gt; 'b <a href="http://mirage.github.io/core/#Command.Spec.param" class="ocaml_internal">param</a></code></pre><div class="info">parameter transformation</div>
<div class="info"><h2 id="2_TITLE">various internal values</h2></div>
<pre class="odoccode"><span class="VALhelp"><span class="keyword">val</span> help</span> : <code class="type">string <a href="http://mirage.github.io/core_kernel/#Std.Lazy.t">Core_kernel.Std.Lazy.t</a> <a href="http://mirage.github.io/core/#Command.Spec.param" class="ocaml_internal">param</a></code></pre><div class="info">the help text for the command</div>
<pre class="odoccode"><span class="VALpath"><span class="keyword">val</span> path</span> : <code class="type">string list <a href="http://mirage.github.io/core/#Command.Spec.param" class="ocaml_internal">param</a></code></pre><div class="info">the subcommand path of the command</div>
<pre class="odoccode"><span class="VALargs"><span class="keyword">val</span> args</span> : <code class="type">string list <a href="http://mirage.github.io/core/#Command.Spec.param" class="ocaml_internal">param</a></code></pre><div class="info">the arguments passed to the command</div>
<div class="info"><h1 id="1_TITLE">command specifications</h1></div>
<pre class="odoccode"><span class="TYPEt"><span class="keyword">type</span> <code class="type">('main_in, 'main_out) </code>t</span></pre><div class="info">composable command-line specifications</div><div class="info">Ultimately one forms a base command by combining a spec of type
<code class="code">('main, unit -&gt; unit) t</code> with a main function of type <code class="code">'main</code>; see the <code class="code">basic</code>
function below. Combinators in this library incrementally build up the type of main
according to what command-line parameters it expects, so the resulting type of
<code class="code">main</code> is something like:<p><code class="code">arg1 -&gt; ... -&gt; argN -&gt; unit -&gt; unit</code></p><p>It may help to think of <code class="code">('a, 'b) t</code> as a function space <code class="code">'a -&gt; 'b</code> embellished with
information about:</p><ul><li>how to parse command line</li><li>what the command does and how to call it</li><li>how to auto-complete a partial command line</li></ul><p>One can view a value of type <code class="code">('main_in, 'main_out) t</code> as function that transforms a
main function from type <code class="code">'main_in</code> to <code class="code">'main_out</code>, typically by supplying some
arguments. E.g. a value of type <code class="code">Spec.t</code> might have type:</p><pre class="code"><code>        (arg1 -&gt; ... -&gt; argN -&gt; 'r, 'r) Spec.t</code></pre><p>Such a value can transform a main function of type <code class="code">arg1 -&gt; ... -&gt; argN -&gt; 'r</code> by
supplying it argument values of type <code class="code">arg1</code>, ..., <code class="code">argn</code>, leaving a main function
whose type is <code class="code">'r</code>. In the end, <code class="code">Command.basic</code> takes a completed spec where
<code class="code">'r = unit -&gt; unit</code>, and hence whose type looks like:</p><pre class="code"><code>        (arg1 -&gt; ... -&gt; argN -&gt; unit -&gt; unit, unit -&gt; unit) Spec.t</code></pre><p>A value of this type can fully apply a main function of type
<code class="code">arg1 -&gt; ... -&gt; argN -&gt; unit -&gt; unit</code> to all its arguments.</p><p>The final unit argument allows the implementation to distinguish between the phases
of (1) parsing the command line and (2) running the body of the command. Exceptions
raised in phase (1) lead to a help message being displayed alongside the exception.
Exceptions raised in phase (2) are displayed without any command line help.</p><p>The view of <code class="code">('main_in, main_out) Spec.t</code> as a function from <code class="code">'main_in</code> to
<code class="code">'main_out</code> is directly reflected by the <code class="code">step</code> function, whose type is:</p><pre class="code"><code>        val step : ('m1 -&gt; 'm2) -&gt; ('m1, 'm2) t</code></pre></div>
<div class="info"><code class="code">spec1 ++ spec2 ++ ... ++ specN</code> composes spec1 through specN.<p>For example, if <code class="code">spec_a</code> and <code class="code">spec_b</code> have types:</p><pre class="code"><code>        spec_a: (a1 -&gt; ... -&gt; aN -&gt; 'ra, 'ra) Spec.t
        spec_b: (b1 -&gt; ... -&gt; bM -&gt; 'rb, 'rb) Spec.t</code></pre><p>then <code class="code">spec_a ++ spec_b</code> has the following type:</p><pre class="code"><code>        (a1 -&gt; ... -&gt; aN -&gt; b1 -&gt; ... -&gt; bM -&gt; 'rb, 'rb) Spec.t</code></pre><p>So, <code class="code">spec_a ++ spec_b</code> transforms a main function it by first supplying <code class="code">spec_a</code>'s
arguments of type <code class="code">a1</code>, ..., <code class="code">aN</code>, and then supplying <code class="code">spec_b</code>'s arguments of type
<code class="code">b1</code>, ..., <code class="code">bm</code>.</p><p>One can understand <code class="code">++</code> as function composition by thinking of the type of specs
as concrete function types, representing the transformation of a main function:</p><pre class="code"><code>        spec_a: \/ra. (a1 -&gt; ... -&gt; aN -&gt; 'ra) -&gt; 'ra
        spec_b: \/rb. (b1 -&gt; ... -&gt; bM -&gt; 'rb) -&gt; 'rb</code></pre><p>Under this interpretation, the composition of <code class="code">spec_a</code> and <code class="code">spec_b</code> has type:</p><pre class="code"><code>        spec_a ++ spec_b : \/rc. (a1 -&gt; ... -&gt; aN -&gt; b1 -&gt; ... -&gt; bM -&gt; 'rc) -&gt; 'rc</code></pre><p>And the implementation is just function composition:</p><pre class="code"><code>        sa ++ sb = fun main -&gt; sb (sa main)</code></pre></div>
<pre class="odoccode"><span class="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">('m, 'm) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a></code></pre><div class="info">the empty command-line spec</div>
<pre class="odoccode"><span class="VAL(++)"><span class="keyword">val</span> (++)</span> : <code class="type">('m1, 'm2) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a> -&gt; ('m2, 'm3) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a> -&gt; ('m1, 'm3) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a></code></pre><div class="info">command-line spec composition</div>
<pre class="odoccode"><span class="VAL(+&gt;)"><span class="keyword">val</span> (+&gt;)</span> : <code class="type">('m1, 'a -&gt; 'm2) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.param" class="ocaml_internal">param</a> -&gt; ('m1, 'm2) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a></code></pre><div class="info">add a rightmost parameter onto the type of main</div>
<pre class="odoccode"><span class="VAL(+&lt;)"><span class="keyword">val</span> (+&lt;)</span> : <code class="type">('m1, 'm2) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.param" class="ocaml_internal">param</a> -&gt; ('a -&gt; 'm1, 'm2) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a></code></pre><div class="info">add a leftmost parameter onto the type of main</div><div class="info">this function should only be used as a workaround in situations where the
order of composition is at odds with the order of anonymous arguments due
to factoring out some common spec</div>
<pre class="odoccode"><span class="VALstep"><span class="keyword">val</span> step</span> : <code class="type">('m1 -&gt; 'm2) -&gt; ('m1, 'm2) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a></code></pre><div class="info">combinator for patching up how parameters are obtained or presented</div><div class="info">Here are a couple examples of some of its many uses
<ul><li><i>introducing labeled arguments</i>
<pre class="verbatim">step (fun m v -&gt; m ~foo:v)
               +&gt; flag &quot;-foo&quot; no_arg : (foo:bool -&gt; 'm, 'm) t</pre></li><li><i>prompting for missing values</i>
<pre class="verbatim">step (fun m user -&gt; match user with
                 | Some user -&gt; m user
                 | None -&gt; print_string &quot;enter username: &quot;; m (read_line ()))
               +&gt; flag &quot;-user&quot; (optional string) ~doc:&quot;USER to frobnicate&quot;
               : (string -&gt; 'm, 'm) t</pre></li></ul><p>A use of <code class="code">step</code> might look something like:</p><pre class="code"><code>        step (fun main -&gt; let ... in main x1 ... xN) : (arg1 -&gt; ... -&gt; argN -&gt; 'r, 'r) t</code></pre><p>Thus, <code class="code">step</code> allows one to write arbitrary code to decide how to transform a main
function. As a simple example:</p><pre class="code"><code>        step (fun main -&gt; main 13.) : (float -&gt; 'r, 'r) t</code></pre><p>This spec is identical to <code class="code">const 13.</code>; it transforms a main function by supplying
it with a single float argument, <code class="code">13.</code>. As another example:</p><pre class="code"><code>        step (fun m v -&gt; m ~foo:v) : (foo:'foo -&gt; 'r, 'foo -&gt; 'r) t</code></pre><p>This spec transforms a main function that requires a labeled argument into
a main function that requires the argument unlabeled, making it easily composable
with other spec combinators.</p></div>
<pre class="odoccode"><span class="VALwrap"><span class="keyword">val</span> wrap</span> : <code class="type">(run:('m1 -&gt; 'r1) -&gt; main:'m2 -&gt; 'r2) -&gt; ('m1, 'r1) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a> -&gt; ('m2, 'r2) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a></code></pre><div class="info">combinator for defining a class of commands with common behavior</div><div class="info">Here are two examples of command classes defined using <code class="code">wrap</code>
<ul><li><i>print top-level exceptions to stderr</i>
<pre class="verbatim">wrap (fun ~run ~main -&gt;
                 Exn.handle_uncaught ~exit:true (fun () -&gt; run main)
               ) : ('m, unit) t -&gt; ('m, unit) t</pre></li><li><i>iterate over lines from stdin</i>
<pre class="verbatim">wrap (fun ~run ~main -&gt;
                 In_channel.iter_lines stdin ~f:(fun line -&gt; run (main line))
               ) : ('m, unit) t -&gt; (string -&gt; 'm, unit) t</pre></li></ul></div>
<div class="info"><h1 id="1_TITLE">argument types</h1></div>
<div class="ocaml_module" name="Arg_type"><pre class="odoccode"><span class="keyword">module</span> <a href="http://mirage.github.io/core/#Command.Spec.Arg_type" class="ocaml_internal">Arg_type</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"/><div class="ocaml_content">
<pre class="odoccode"><span class="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t</span></pre><div class="info">the type of a command line argument</div>
<pre class="odoccode"><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?complete:(<a href="http://mirage.github.io/core_kernel/#Std.Univ_map.t">Core_kernel.Std.Univ_map.t</a> -&gt; part:string -&gt; string list) -&gt;
?key:'a <a href="http://mirage.github.io/core_kernel/#Std.Univ_map.Multi.Key.t">Core_kernel.Std.Univ_map.Multi.Key.t</a> -&gt; (string -&gt; 'a) -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">t</a></code></pre><div class="info">an argument type includes information about how to parse values of that type from
the command line, and (optionally) how to auto-complete partial arguments of that
type via bash's programmable TAB-completion. In addition to the argument prefix,
autocompletion also has access to any previously parsed arguments in the form of a
heterogeneous map into which previously parsed arguments may register themselves by
providing a Univ_map.Key using the ~key argument to <code class="code">create</code>.<p>If the <code class="code">of_string</code> function raises an exception, command line parsing will be
aborted and the exception propagated up to top-level and printed along with
command-line help.</p></div>
<pre class="odoccode"><span class="VALof_map"><span class="keyword">val</span> of_map</span> : <code class="type">?key:'a <a href="http://mirage.github.io/core_kernel/#Std.Univ_map.Multi.Key.t">Core_kernel.Std.Univ_map.Multi.Key.t</a> -&gt;
'a <a href="http://mirage.github.io/core_kernel/#Std.String.Map.t">Core_kernel.Std.String.Map.t</a> -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">t</a></code></pre><div class="info">an auto-completing Arg_type over a finite set of values</div>
<pre class="odoccode"><span class="VALof_alist_exn"><span class="keyword">val</span> of_alist_exn</span> : <code class="type">?key:'a <a href="http://mirage.github.io/core_kernel/#Std.Univ_map.Multi.Key.t">Core_kernel.Std.Univ_map.Multi.Key.t</a> -&gt; (string * 'a) list -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">t</a></code></pre><div class="info">convenience wrapper for <code class="code">of_map</code>. Raises on duplicate keys</div></div></div>
<pre class="odoccode"><span class="VALstring"><span class="keyword">val</span> string</span> : <code class="type">string <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a></code></pre>
<pre class="odoccode"><span class="VALint"><span class="keyword">val</span> int</span> : <code class="type">int <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a></code></pre>
<pre class="odoccode"><span class="VALfloat"><span class="keyword">val</span> float</span> : <code class="type">float <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a></code></pre>
<pre class="odoccode"><span class="VALbool"><span class="keyword">val</span> bool</span> : <code class="type">bool <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a></code></pre>
<pre class="odoccode"><span class="VALdate"><span class="keyword">val</span> date</span> : <code class="type"><a href="http://mirage.github.io/core/#Date.t">Date.t</a> <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a></code></pre>
<pre class="odoccode"><span class="VALtime_span"><span class="keyword">val</span> time_span</span> : <code class="type"><a href="http://mirage.github.io/core/#Span.t">Span.t</a> <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a></code></pre>
<pre class="odoccode"><span class="VALfile"><span class="keyword">val</span> file</span> : <code class="type">string <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a></code></pre>
<div class="info"><h1 id="1_TITLE">flag specifications</h1></div>
<pre class="odoccode"><span class="TYPEflag"><span class="keyword">type</span> <code class="type">'a </code>flag</span></pre><div class="info">a flag specification</div>
<pre class="odoccode"><span class="VALflag"><span class="keyword">val</span> flag</span> : <code class="type">?aliases:string list -&gt; string -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">flag</a> -&gt; doc:string -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.param" class="ocaml_internal">param</a></code></pre><div class="info"><code class="code">flag name spec ~doc</code> specifies a command that, among other things, takes a flag
named <code class="code">name</code> on its command line. <code class="code">doc</code> indicates the meaning of the flag.<p>All flags must have a dash at the beginning of the name. If <code class="code">name</code> is not prefixed
by &quot;-&quot;, it will be normalized to <code class="code">&quot;-&quot; ^ name</code>.</p><p>NOTE: the <code class="code">doc</code> for a flag which takes an argument should be of the form
<code class="code">arg_name ^ &quot; &quot; ^ description</code> where <code class="code">arg_name</code> describes the argument and
<code class="code">description</code> describes the meaning of the flag.</p><p>NOTE: flag names (including aliases) containing underscores will be rejected.
Use dashes instead.</p><p>NOTE: &quot;-&quot; by itself is an invalid flag name and will be rejected.</p></div>
<pre class="odoccode"><span class="VALmap_flag"><span class="keyword">val</span> map_flag</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">flag</a> -&gt; f:('a -&gt; 'b) -&gt; 'b <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">flag</a></code></pre><div class="info"><code class="code">map_flag flag ~f</code> transforms the parsed result of <code class="code">flag</code> by applying <code class="code">f</code></div>
<pre class="odoccode"><span class="VALrequired"><span class="keyword">val</span> required</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a> -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">flag</a></code></pre><div class="info">required flags must be passed exactly once</div>
<pre class="odoccode"><span class="VALoptional"><span class="keyword">val</span> optional</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a> -&gt; 'a option <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">flag</a></code></pre><div class="info">optional flags may be passed at most once</div>
<pre class="odoccode"><span class="VALoptional_with_default"><span class="keyword">val</span> optional_with_default</span> : <code class="type">'a -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a> -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">flag</a></code></pre><div class="info"><code class="code">optional_with_default</code> flags may be passed at most once, and
default to a given value</div>
<pre class="odoccode"><span class="VALlisted"><span class="keyword">val</span> listed</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a> -&gt; 'a list <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">flag</a></code></pre><div class="info"><code class="code">listed</code> flags may be passed zero or more times</div>
<pre class="odoccode"><span class="VALno_arg"><span class="keyword">val</span> no_arg</span> : <code class="type">bool <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">flag</a></code></pre><div class="info"><code class="code">no_arg</code> flags may be passed at most once. The boolean returned
is true iff the flag is passed on the command line</div>
<pre class="odoccode"><span class="VALno_arg_register"><span class="keyword">val</span> no_arg_register</span> : <code class="type">key:'a <a href="http://mirage.github.io/core_kernel/#Std.Univ_map.With_default.Key.t">Core_kernel.Std.Univ_map.With_default.Key.t</a> -&gt; value:'a -&gt; bool <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">flag</a></code></pre><div class="info"><code class="code">no_arg_register ~key ~value</code> is like <code class="code">no_arg</code>, but associates <code class="code">value</code>
with <code class="code">key</code> in the in the auto-completion environment</div>
<pre class="odoccode"><span class="VALno_arg_abort"><span class="keyword">val</span> no_arg_abort</span> : <code class="type">exit:(unit -&gt; <a href="http://mirage.github.io/core_kernel/#Std.never_returns">Core_kernel.Std.never_returns</a>) -&gt; unit <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">flag</a></code></pre><div class="info"><code class="code">no_arg_abort ~exit</code> is like <code class="code">no_arg</code>, but aborts command-line parsing
by calling <code class="code">exit</code>. This flag type is useful for &quot;help&quot;-style flags that
just print something and exit.</div>
<pre class="odoccode"><span class="VALescape"><span class="keyword">val</span> escape</span> : <code class="type">string list option <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">flag</a></code></pre><div class="info"><code class="code">escape</code> flags may be passed at most once. They cause the command line parser to
abort and pass through all remaining command line arguments as the value of the
flag.<p>A standard choice of flag name to use with <code class="code">escape</code> is <code class="code">&quot;--&quot;</code>.</p></div>
<pre class="odoccode"><span class="VALflags_of_args_exn"><span class="keyword">val</span> flags_of_args_exn</span> : <code class="type"><a href="http://mirage.github.io/core_kernel/#Std.Arg.t">Core_kernel.Std.Arg.t</a> list -&gt; ('a, 'a) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">flags_of_args_exn args</code> creates a spec from <code class="code">Arg.t</code>s, for compatibility with
ocaml's base libraries. Fails if it encounters an arg that cannot be converted.<p>NOTE: There is a difference in side effect ordering between <code class="code">Arg</code> and <code class="code">Command</code>. In
the <code class="code">Arg</code> module, flag handling functions embedded in <code class="code">Arg.t</code> values will be run in
the order that flags are passed on the command line. In the <code class="code">Command</code> module, using
<code class="code">flags_of_args_exn flags</code>, they are evaluated in the order that the <code class="code">Arg.t</code> values
appear in <code class="code">flags</code>.</p></div>
<div class="info"><h1 id="1_TITLE">anonymous argument specifications</h1></div>
<pre class="odoccode"><span class="TYPEanons"><span class="keyword">type</span> <code class="type">'a </code>anons</span></pre><div class="info">a specification of some number of anonymous arguments</div>
<pre class="odoccode"><span class="VALanon"><span class="keyword">val</span> anon</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.param" class="ocaml_internal">param</a></code></pre><div class="info"><code class="code">anon spec</code> specifies a command that, among other things, takes
the anonymous arguments specified by <code class="code">spec</code>.</div>
<pre class="odoccode"><span class="VALmap_anons"><span class="keyword">val</span> map_anons</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; f:('a -&gt; 'b) -&gt; 'b <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a></code></pre><div class="info"><code class="code">map_anons anons ~f</code> transforms the parsed result of <code class="code">anons</code> by applying <code class="code">f</code></div>
<pre class="odoccode"><span class="VAL%:"><span class="keyword">val</span> %:</span> : <code class="type">string -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.Arg_type.t" class="ocaml_internal">Arg_type.t</a> -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a></code></pre><div class="info"><code class="code">(name %: typ)</code> specifies a required anonymous argument of type <code class="code">typ</code>.<p>The <code class="code">name</code> must not be surrounded by whitespace, if it is, an exn will be raised.</p><p>If the <code class="code">name</code> is surrounded by a special character pair (&lt;&gt;, {}, [] or (),)
<code class="code">name</code> will remain as-is, otherwise, <code class="code">name</code> will be uppercased.</p><p>In the situation where <code class="code">name</code> is only prefixed or only suffixed by one of the
special character pairs, or different pairs are used, (e.g. &quot;&lt;ARG]&quot;) an exn will
be raised.</p><p>The (possibly transformed) <code class="code">name</code> is mentioned in the generated help for the
command.</p></div>
<pre class="odoccode"><span class="VALsequence"><span class="keyword">val</span> sequence</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; 'a list <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a></code></pre><div class="info"><code class="code">sequence anons</code> specifies a sequence of anonymous arguments. An exception
will be raised if <code class="code">anons</code> matches anything other than a fixed number of
anonymous arguments</div>
<pre class="odoccode"><span class="VALmaybe"><span class="keyword">val</span> maybe</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; 'a option <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a></code></pre><div class="info"><code class="code">(maybe anons)</code> indicates that some anonymous arguments are optional</div>
<pre class="odoccode"><span class="VALmaybe_with_default"><span class="keyword">val</span> maybe_with_default</span> : <code class="type">'a -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; 'a <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a></code></pre><div class="info"><code class="code">(maybe_with_default default anons)</code> indicates an optional anonymous
argument with a default value</div>
<div class="info"><code class="code">t2</code>, <code class="code">t3</code>, and <code class="code">t4</code> each concatenate multiple anonymous argument
specs into a single one. The purpose of these combinators is to allow
for optional sequences of anonymous arguments. Consider a command with
usage:<pre class="verbatim">        main.exe FOO [BAR BAZ]</pre><p>where the second and third anonymous arguments must either both
be there or both not be there. This can be expressed as:</p><pre class="code"><code>        t2 (&quot;FOO&quot; %: foo) (maybe (t2 (&quot;BAR&quot; %: bar) (&quot;BAZ&quot; %: baz)))]</code></pre><p>Sequences of 5 or more anonymous arguments can be built up using
nested tuples:</p><pre class="code"><code>        maybe (t3 a b (t3 c d e))</code></pre></div>
<pre class="odoccode"><span class="VALt2"><span class="keyword">val</span> t2</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; 'b <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; ('a * 'b) <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a></code></pre>
<pre class="odoccode"><span class="VALt3"><span class="keyword">val</span> t3</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; 'b <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; 'c <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; ('a * 'b * 'c) <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a></code></pre>
<pre class="odoccode"><span class="VALt4"><span class="keyword">val</span> t4</span> : <code class="type">'a <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; 'b <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; 'c <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; 'd <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a> -&gt; ('a * 'b * 'c * 'd) <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">anons</a></code></pre></div></div>
<pre class="odoccode"><span class="TYPEt"><span class="keyword">type</span> t</span></pre><div class="info">commands which can be combined into a hierarchy of subcommands</div>
<pre class="odoccode"><span class="VALbasic"><span class="keyword">val</span> basic</span> : <code class="type">summary:string -&gt;
?readme:(unit -&gt; string) -&gt; ('main, unit -&gt; unit) <a href="http://mirage.github.io/core/#Command.Spec.t" class="ocaml_internal">Spec.t</a> -&gt; 'main -&gt; <a href="http://mirage.github.io/core/#Command.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">basic ~summary ?readme spec main</code> is a basic command that executes a function <code class="code">main</code>
which is passed parameters parsed from the command line according to <code class="code">spec</code>. <code class="code">summary</code>
is to contain a short one-line description of its behavior. <code class="code">readme</code> is to contain
any longer description of its behavior that will go on that commands' help screen.</div>
<pre class="odoccode"><span class="VALgroup"><span class="keyword">val</span> group</span> : <code class="type">summary:string -&gt; ?readme:(unit -&gt; string) -&gt; (string * <a href="http://mirage.github.io/core/#Command.t" class="ocaml_internal">t</a>) list -&gt; <a href="http://mirage.github.io/core/#Command.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">group ~summary subcommand_alist</code> is a compound command with named
subcommands, as found in <code class="code">subcommand_alist</code>. <code class="code">summary</code> is to contain
a short one-line description of the command group. <code class="code">readme</code> is to
contain any longer description of its behavior that will go on that
command's help screen.<p>NOTE: subcommand names containing underscores will be rejected. Use dashes instead.</p></div>
<pre class="odoccode"><span class="VALrun"><span class="keyword">val</span> run</span> : <code class="type">?version:string -&gt;
?build_info:string -&gt;
?argv:string list -&gt; ?extend:(string list -&gt; string list) -&gt; <a href="http://mirage.github.io/core/#Command.t" class="ocaml_internal">t</a> -&gt; unit</code></pre><div class="info">Run a command against <code class="code">Sys.argv</code>, or <code class="code">argv</code> if it is specified.<p><code class="code">extend</code> can be used to add extra command line arguments to basic subcommands of the
command. <code class="code">extend</code> will be passed the (fully expanded) path to a command, and its
output will be appended to the list of arguments being processed. For example,
suppose a program like this is compiled into <code class="code">exe</code>:</p><pre class="code"><code>        let bar = Command.basic ...
        let foo = Command.group ~summary:... [&quot;bar&quot;, bar]
        let main = Command.group ~summary:... [&quot;foo&quot;, foo]
        Command.run ~extend:(fun _ -&gt; [&quot;-baz&quot;]) main</code></pre><p>Then if a user ran <code class="code">exe f b</code>, <code class="code">extend</code> would be passed <code class="code">[&quot;foo&quot;; &quot;bar&quot;]</code> and <code class="code">&quot;-baz&quot;</code>
would be appended to the command line for processing by <code class="code">bar</code>. This can be used to
add a default flags section to a user config file.</p></div>
<div class="ocaml_module" name="Deprecated"><pre class="odoccode"><span class="keyword">module</span> <a href="http://mirage.github.io/core/#Command.Deprecated" class="ocaml_internal">Deprecated</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"><div class="info"><code class="code">Deprecated</code> should be used only by <code class="code">Core_extended.Deprecated_command</code>. At some point
it will go away.</div></div><div class="ocaml_content">
<div class="ocaml_module" name="Spec"><pre class="odoccode"><span class="keyword">module</span> <a href="http://mirage.github.io/core/#Command.Deprecated.Spec" class="ocaml_internal">Spec</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"/><div class="ocaml_content">
<pre class="odoccode"><span class="VALno_arg"><span class="keyword">val</span> no_arg</span> : <code class="type">hook:(unit -&gt; unit) -&gt; bool <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">Spec.flag</a></code></pre>
<pre class="odoccode"><span class="VALescape"><span class="keyword">val</span> escape</span> : <code class="type">hook:(string list -&gt; unit) -&gt; string list option <a href="http://mirage.github.io/core/#Command.Spec.flag" class="ocaml_internal">Spec.flag</a></code></pre>
<pre class="odoccode"><span class="VALad_hoc"><span class="keyword">val</span> ad_hoc</span> : <code class="type">usage_arg:string -&gt; string list <a href="http://mirage.github.io/core/#Command.Spec.anons" class="ocaml_internal">Spec.anons</a></code></pre></div></div>
<pre class="odoccode"><span class="VALsummary"><span class="keyword">val</span> summary</span> : <code class="type"><a href="http://mirage.github.io/core/#Command.t" class="ocaml_internal">t</a> -&gt; string</code></pre>
<pre class="odoccode"><span class="VALhelp_recursive"><span class="keyword">val</span> help_recursive</span> : <code class="type">cmd:string -&gt;
with_flags:bool -&gt; expand_dots:bool -&gt; <a href="http://mirage.github.io/core/#Command.t" class="ocaml_internal">t</a> -&gt; string -&gt; (string * string) list</code></pre>
<pre class="odoccode"><span class="VALrun"><span class="keyword">val</span> run</span> : <code class="type"><a href="http://mirage.github.io/core/#Command.t" class="ocaml_internal">t</a> -&gt;
cmd:string -&gt;
args:string list -&gt;
is_help:bool -&gt;
is_help_rec:bool -&gt; is_help_rec_flags:bool -&gt; is_expand_dots:bool -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALget_flag_names"><span class="keyword">val</span> get_flag_names</span> : <code class="type"><a href="http://mirage.github.io/core/#Command.t" class="ocaml_internal">t</a> -&gt; string list</code></pre>
<pre class="odoccode"><span class="VALversion"><span class="keyword">val</span> version</span> : <code class="type">string</code></pre>
<pre class="odoccode"><span class="VALbuild_info"><span class="keyword">val</span> build_info</span> : <code class="type">string</code></pre></div></div>
</div></div>