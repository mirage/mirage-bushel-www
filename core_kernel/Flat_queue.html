<div class="ocaml_top"><div class="ocaml_summary"><div class="info">A queue of flat tuples, represented in a Flat_array.<p>The elements of a queue are numbered 0, 1, ..., <code class="code">length t - 1</code>, where element <code class="code">0</code> is
at the front of the queue. One can access the <code class="code">j</code>'th component of the <code class="code">i</code>'th element
using <code class="code">get t i Slot.tj</code>.</p><p>A flat tuple is like an ordinary OCaml tuple, except it is second class and mutable.
The flat tuples in a flat queue are layed out sequentially, with each flat tuple's
components immediately following the components of the prior flat tuple. A flat tuple
is not first class -- one can only refer to a flat tuple via its index in the queue
holding it. Flat tuples are mutable via <code class="code">Flat_queue.set</code>.</p></div></div>
<div class="ocaml_content"><div class="ocaml_module" name="Slots" path="http://mirage.github.io/core_kernel/#Tuple_type:Slots"><pre class="odoccode"><span class="keyword">module</span> <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots" class="ocaml_internal">Slots</a> : <code class="type"><code class="code"><a href="http://mirage.github.io/core_kernel/#Tuple_type:Slots">Tuple_type.Slots</a></code></code></pre><div class="ocaml_summary"/></div>
<div class="ocaml_module" name="Slot" path="http://mirage.github.io/core_kernel/#Tuple_type:Slot"><pre class="odoccode"><span class="keyword">module</span> <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slot" class="ocaml_internal">Slot</a> : <code class="type"><code class="code"><a href="http://mirage.github.io/core_kernel/#Tuple_type:Slot">Tuple_type.Slot</a></code></code></pre><div class="ocaml_summary"/></div>
<pre class="odoccode"><span class="TYPEt"><span class="keyword">type</span> <code class="type">'slots </code>t</span></pre><div class="info">The type of a flat queue. <code class="code">'slots</code> will look like <code class="code">('a1, ..., 'an) Slots.tn</code>, and the
queue holds flat tuples of type <code class="code">'a1 * ... * 'an</code>.</div>
<div class="ocaml_include" path="http://mirage.github.io/core_kernel/#Invariant:S1" items="[]" types="[]"><pre class="ocaml_include_handle"><span class="keyword">include</span> <code class="type"><code class="code"><a href="http://mirage.github.io/core_kernel/#Invariant:S1">Invariant.S1</a></code> with type t := 'a <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a></code></pre><div class="ocaml_summary"/></div>
<pre class="odoccode"><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?capacity:int -&gt; ('a, 'b) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t" class="ocaml_internal">Slots.t</a> -&gt; ('a, 'b) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t" class="ocaml_internal">Slots.t</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">create ?capacity slots</code> creates an empty queue with capacity at least the supplied
<code class="code">capacity</code>. It is an error if <code class="code">capacity &lt;= 0</code>.</div>
<pre class="odoccode"><span class="VALcapacity"><span class="keyword">val</span> capacity</span> : <code class="type">'a <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; int</code></pre><div class="info"><code class="code">capacity t</code> returns the length of the array backing <code class="code">t</code>. Enqueueing values will not
cause the array to grow as long as <code class="code">length t &lt;= capacity t</code>. A queue at capacity
will automatically increase capacity when enqueueing. The capacity never decreases
automatically; one can only decrease capacity via <code class="code">set_capacity</code>.</div>
<pre class="odoccode"><span class="VALset_capacity"><span class="keyword">val</span> set_capacity</span> : <code class="type">'a <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; int -&gt; unit</code></pre><div class="info"><code class="code">set_capacity t capacity</code> sets the length of the array backing <code class="code">t</code> to as small as
value as possible that is not less than <code class="code">max capacity (length t)</code>. To shrink as much
as possible, do <code class="code">set_capacity t 0</code>.</div>
<pre class="odoccode"><span class="VALlength"><span class="keyword">val</span> length</span> : <code class="type">'a <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; int</code></pre>
<pre class="odoccode"><span class="VALis_empty"><span class="keyword">val</span> is_empty</span> : <code class="type">'a <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; bool</code></pre>
<pre class="odoccode"><span class="VALget"><span class="keyword">val</span> get</span> : <code class="type">('b, 'v) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t" class="ocaml_internal">Slots.t</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; int -&gt; ('v, 'a) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slot.t" class="ocaml_internal">Slot.t</a> -&gt; 'a</code></pre><div class="info">These functions get and set individual slots of flat tuple <code class="code">i</code> in queue <code class="code">t</code>.<p>It is required that <code class="code">0 &lt;= i &lt; length t</code>.</p></div>
<pre class="odoccode"><span class="VALunsafe_get"><span class="keyword">val</span> unsafe_get</span> : <code class="type">('b, 'v) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t" class="ocaml_internal">Slots.t</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; int -&gt; ('v, 'a) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slot.t" class="ocaml_internal">Slot.t</a> -&gt; 'a</code></pre>
<pre class="odoccode"><span class="VALset"><span class="keyword">val</span> set</span> : <code class="type">('b, 'v) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t" class="ocaml_internal">Slots.t</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; int -&gt; ('v, 'a) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slot.t" class="ocaml_internal">Slot.t</a> -&gt; 'a -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALunsafe_set"><span class="keyword">val</span> unsafe_set</span> : <code class="type">('b, 'v) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t" class="ocaml_internal">Slots.t</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; int -&gt; ('v, 'a) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slot.t" class="ocaml_internal">Slot.t</a> -&gt; 'a -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALdrop_front"><span class="keyword">val</span> drop_front</span> : <code class="type">?n:int -&gt; 'a <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; unit</code></pre><div class="info"><code class="code">drop_front ?n t</code> drops the the first <code class="code">n</code> elements of <code class="code">t</code>. It raises if <code class="code">n &lt; 0 || n &gt;
    length t</code>.<p><code class="code">Flat_queue</code> does not have <code class="code">dequeue</code> or <code class="code">dequeue_exn</code> because the expected usage is to
use <code class="code">get t 0 Slot.tj</code> to access the front of the queue, and then to use <code class="code">drop_front</code>
to remove it. This usage avoids ever allocating an ordinary OCaml tuple.</p></div>
<pre class="odoccode"><span class="VALclear"><span class="keyword">val</span> clear</span> : <code class="type">'a <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; unit</code></pre><div class="info"><code class="code">clear t</code> removes all elements from <code class="code">t</code>.</div>
<pre class="odoccode"><span class="VALenqueue1"><span class="keyword">val</span> enqueue1</span> : <code class="type">'a0 <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t1" class="ocaml_internal">Slots.t1</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; 'a0 -&gt; unit</code></pre><div class="info">There is an <code class="code">enqueueN</code> function for each possible arity of a flat queue.</div>
<pre class="odoccode"><span class="VALenqueue2"><span class="keyword">val</span> enqueue2</span> : <code class="type">('a0, 'a1) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t2" class="ocaml_internal">Slots.t2</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; 'a0 -&gt; 'a1 -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALenqueue3"><span class="keyword">val</span> enqueue3</span> : <code class="type">('a0, 'a1, 'a2) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t3" class="ocaml_internal">Slots.t3</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; 'a0 -&gt; 'a1 -&gt; 'a2 -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALenqueue4"><span class="keyword">val</span> enqueue4</span> : <code class="type">('a0, 'a1, 'a2, 'a3) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t4" class="ocaml_internal">Slots.t4</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; 'a0 -&gt; 'a1 -&gt; 'a2 -&gt; 'a3 -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALenqueue5"><span class="keyword">val</span> enqueue5</span> : <code class="type">('a0, 'a1, 'a2, 'a3, 'a4) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t5" class="ocaml_internal">Slots.t5</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt;
'a0 -&gt; 'a1 -&gt; 'a2 -&gt; 'a3 -&gt; 'a4 -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALenqueue6"><span class="keyword">val</span> enqueue6</span> : <code class="type">('a0, 'a1, 'a2, 'a3, 'a4, 'a5) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t6" class="ocaml_internal">Slots.t6</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt;
'a0 -&gt; 'a1 -&gt; 'a2 -&gt; 'a3 -&gt; 'a4 -&gt; 'a5 -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALenqueue7"><span class="keyword">val</span> enqueue7</span> : <code class="type">('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t7" class="ocaml_internal">Slots.t7</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt;
'a0 -&gt; 'a1 -&gt; 'a2 -&gt; 'a3 -&gt; 'a4 -&gt; 'a5 -&gt; 'a6 -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALenqueue8"><span class="keyword">val</span> enqueue8</span> : <code class="type">('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t8" class="ocaml_internal">Slots.t8</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt;
'a0 -&gt; 'a1 -&gt; 'a2 -&gt; 'a3 -&gt; 'a4 -&gt; 'a5 -&gt; 'a6 -&gt; 'a7 -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALenqueue9"><span class="keyword">val</span> enqueue9</span> : <code class="type">('a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7, 'a8) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t9" class="ocaml_internal">Slots.t9</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt;
'a0 -&gt; 'a1 -&gt; 'a2 -&gt; 'a3 -&gt; 'a4 -&gt; 'a5 -&gt; 'a6 -&gt; 'a7 -&gt; 'a8 -&gt; unit</code></pre>
<div class="info">The functions below deal with Flat-array tuples as ordinary OCaml tuples. These
are intended for convenience but not for performance-critical code, due to the
tuple allocation.</div>
<pre class="odoccode"><span class="VALget_all_slots"><span class="keyword">val</span> get_all_slots</span> : <code class="type">('tuple, 'a) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t" class="ocaml_internal">Slots.t</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; int -&gt; 'tuple</code></pre><div class="info"><code class="code">get_all_slots t i</code> allocates a new ordinary OCaml tuple whose components are equal to
the slots of the flat tuple at index <code class="code">i</code> of <code class="code">t</code>. This is esentially an allocation
plus a blit from <code class="code">t</code> to the newly allocated tuple.<p><code class="code">set_all_slots t i tuple</code> sets all slots of the flat tuple at index <code class="code">i</code> of <code class="code">t</code> to
their corresponding components of <code class="code">tuple</code>. This is essentially a blit from <code class="code">tuple</code> to
<code class="code">t</code>.</p><p>It is required that <code class="code">0 &lt;= i &lt; length t</code>.</p></div>
<pre class="odoccode"><span class="VALset_all_slots"><span class="keyword">val</span> set_all_slots</span> : <code class="type">('tuple, 'a) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t" class="ocaml_internal">Slots.t</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; int -&gt; 'tuple -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('tuple, 'b) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t" class="ocaml_internal">Slots.t</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; init:'a -&gt; f:('a -&gt; 'tuple -&gt; 'a) -&gt; 'a</code></pre><div class="info">In <code class="code">iter t ~f</code> and <code class="code">fold t ~init ~f</code>, if <code class="code">f</code> mutates <code class="code">t</code>, then the iteration will
raise.</div>
<pre class="odoccode"><span class="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">('tuple, 'a) <a href="http://mirage.github.io/core_kernel/#Flat_queue.Slots.t" class="ocaml_internal">Slots.t</a> <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; f:('tuple -&gt; unit) -&gt; unit</code></pre>
<pre class="odoccode"><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('slots -&gt; <a href="http://mirage.github.io/sexplib/#Sexp.t">Sexplib.Sexp.t</a>) -&gt; 'slots <a href="http://mirage.github.io/core_kernel/#Flat_queue.t" class="ocaml_internal">t</a> -&gt; <a href="http://mirage.github.io/sexplib/#Sexp.t">Sexplib.Sexp.t</a></code></pre>
</div></div>